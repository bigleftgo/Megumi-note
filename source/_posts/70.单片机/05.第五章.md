---
title: 第五章-单片机与显示器件以及开关、键盘的接口设计
toc: true
math: true
---

# 单片机控制发光二极管显示

- 大部分发光二极管**工作电流1~5mA**之间，其**内阻为20~100Ω**。电流越大，亮度也越高。
- 为保证发光二极管正常工作，同时减少功耗，**限流电阻选择十分重要**，若供电电压为+5V，则**限流电阻可选1~3kΩ**。

## 单片机与发光二极管的连接

- 第2章已介绍，P0口作通用I/O用，由于漏极开路，需外接上拉电阻。而**P1～P3口内部有30kΩ左右上拉电阻**

- 单片机并行端口P1～P3直接驱动发光二极管，电路见[图5-1](#5-1)。
  与P1、P2、P3口相比，P0口每位可驱动**8个LSTTL输入**，而P1～P3口每一位驱动能力，只有**P0口一半**。

- <a name="5-1"> </a><img src="http://222.65.137.121:9702/images/2020/10/07/image-20201008094838085.png" alt="image-20201008094838085" style="zoom:50%;" />

  > 当P0口某位为高电平时，可提供400µA的拉电流；当P0口某位为低电平（0.45V）时，可提供3.2mA的灌电流，而P1～P3口内有30kΩ左右上拉电阻，如高电平输出，则从P1、P2和P3口输出的拉电流Id仅几百µA，驱动能力较弱，亮度较差
  >
  > 如果端口引脚为低电平，能使灌电流Id从单片机外部流入内部，则将大大增加流过的灌电流值，见图5-1（b）。AT89S51任一端口要想获得较大的驱动能力，要用低电平输出

## I/O端口的编程举例

- 对单片机I/O端口进行编程控制时，需要对I/O端口的特殊功能寄存器进行声明，在C51的编译器中，这项声明包含在头文件reg51.h中，编程时，可通过预处理命令#include<reg51.h>，把这个头文件包含进去。

- > 例：制作流水灯，原理电路见[图5-2](#5-2)，8个发光二极管LED0～LED7经限流电阻分别接至P1口的P1.0～P1.7引脚上，阳极共同接高电平。编写程序来控制发光二极管由上至下的反复循环流水点亮，每次点亮一个发光二极管。
  >
  > ```c#
  > #include <reg51.h>
  > #include <intrins.h>	//包含移位函数_crol()的头文件
  > #define uchar unsigned char
  > #define uint unsigned int
  > void delay(uint i)		//延时函数
  > {
  > uchar t;
  > while (i--)
  > {
  > for(t=0;t<120;t++)
  > }
  > }
  > void main()		//主程序
  > {
  > P1=0xfe;		//向P1口送出点亮数据
  > while(1)
  > {
  > delay(500);		//500为延时函数，可根据实际需要调整
  > P1=_crol_(P1,1);	//函数_crol_(P1,1)把P1中的数据循环左移一位
  > }
  > }
  > ```
  >
  > <a name="5-2">5-2</a>
  >
  > <img src="http://222.65.137.121:9702/images/2020/10/07/image-20201008095722391.png" alt="image-20201008095722391" style="zoom:50%;" />
  >
  > 例：电路见[图5-2](#5-2)，制作由上至下再由下至上反复循环点亮显示的流水灯，3种方法实现。
  >
  > 1. 数组的字节操作实现：建立1个字符型数组，将控制8个LED显示的8位数据作为数组元素，依次送P1口
  >
  >    ```C#
  >    #include<reg51.h>
  >    #define uchar unsigned char
  >    uchar tab[]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f,0x7f,0xbf,0xdf,0xef,0xf7, 0xfb,0xfd,0xfe}		//前8个数据为左移点亮 数据，后8个为右移点亮数据
  >    void delay()
  >    {
  >      uchar i,j
  >        for(i=0;i<255;i++)
  >        for(j=0;j<255,j++);
  >    }
  >    void main()		//主函数
  >    {
  >      uchar i;
  >      while(1)
  >      {
  >        for(i=0;i<16;i++)
  >        {
  >          P1=tab[i];		//向P1口送出点亮数据
  >          delay();
  >        }
  >      }
  >    }
  >    ```
  >    
  > 2. 移位运算符实现：使用移位运算符“>>”、“<<”，把送P1口显示控制数据进行移位，从而实现发光二极管依次点亮
  >
  > ```C#
  > #include<reg51.h>
  > #define uchar unsigned char
  > void delay()
  > {
  >   uchar i,j;
  >   for(i=0;i<255;i++)
  >   for(j=0;j<255,j++);
  > }
  > void main()		//主函数
  > {
  >   uchar i,temp;
  >   while(1)
  > 
  > {
  >   temp=0x01		//左移初值赋给temp
  >   for(i=0;i<8;i++)
  >   {
  >     P1=~temp;		//temp中的数据取反后送P1口
  >       delay();		//延时
  >       temp=temp<<1;		//temp中数据左移一位
  >   }
  >   temp=0x80		//赋右移初值给temp
  >   for(i=0;i<8;i++)
  >   {
  >     P1=~temp;
  >     delay;
  >     temp=temp>>1;		//temp中数据右移一位
  >   }
  > }
  > }
  > ```
  >
  > 注意：使用移位运算符“>>”、“<<”与使用循环左移函数“_ crol _ ”和循环右移函数“_ cror _” 区别
  >
  > 3. 用循环左、右移位函数实现：使用C51提供的库函数，即循环左移n位函数和循环右移n位函数，控制发光二极管点亮
  >
  > ```C#
  > #include <reg51.h>
  > #include <intrins.h>		/包含左、右移位函数的头文件
  > #define uchar unsigned char
  > void delay()
  > {
  >   uchar i,j;
  >   for(i=0;i<255;i++);
  >   for(j=0;j<255;j++);
  > }
  > void main()		//主函数
  > {
  >   uchar i,temp;
  >   while(1)
  >   {
  >     temp=0xfe;		//初值为11111110
  >     for(i=0;i<7;i++)
  >     {
  >       P1=temp;		//temp中的点亮数据送P1口，控制点亮显示
  >       delay();		//延时
  >       temp=_crol_(temp,1);		//temp数据循环左移一位
  >     }
  >     for(i=0;i<7;i++)
  >     {
  >       P1=temp;		//temp中的数据送P1口输出
  >       delay();		//延时
  >       temp=_cror_(temp,1);		//temp中数据循环右移一位
  >     }
  >   }
  > }
  > ```
  >
  > 

# 开关状态检测

- 检测一个开关处于闭合状态还是打开状态，只需将被检测的开关一端接到I/O端口的引脚上，另一端接地，通过读入I/O端口的电平来判断开关是闭合状态还是处于打开状态。如果为低电平，则开关为闭合状态。

## 开关检测案例1

- 用I/O端口来进行开关状态检测，开关一端接到I/O端口引脚上，并通过上拉电阻接+5V上，开关另一端接地，当开关打开时，I/O引脚为高电平，当开关闭合时，I/O引脚为低电平。

> 例：如[图5-3](#5-3)，单片机的P1.4～P1.7接4个开关S0～S3，P1.0～P1.3接4个发光二极管LED0～LED3。编程将P1.4～P1.7上的4个开关状态反映在P1.0～P1.3引脚控制的4个发光二极管上，开关闭合，对应发光二极管点亮。例如P1.4引脚上开关S0状态，由P1.0脚上LED0显示，P1.6引脚上开关S2状态，由P1.2脚的LED2显示。 
>
> <a name="5-3">图5-3</a>
>
> <img src="http://222.65.137.121:9702/images/2020/10/07/image-20201008103956927.png" alt="image-20201008103956927" style="zoom:50%;" />
>
> ```c#
> #include <reg51.h>
> #define uchar unsighed char
> void delay()		//延时函数
> {
>   uchar i,j;
>   for(i=0;i<255;i++);
>   for(j=0;j<255;j++);
> }
> void main()		//主函数
> {
>   while(1)
>   {
>     unsigned char temp;		//定义临时变量temp
>     P1=0xff;		//P1口低4位置1，作为输入；高4位置1，发光二极管熄灭
>     temp=P1&0xf0;		//读P1口并屏蔽低4位，送入temp中
>     temp=temp>>4;		//temp内容右移4位，P1口高4位送至低4位
>     P1=temp;		//temp中的数据送P1口输出
>     delay();
>   }
> }
> ```

## 开关检测案例2

> 例：如[图5-4](#5-4)，P1.0和P1.1引脚接有两只开关S0和S1，两引脚上的高低电平共4种组合，4种组合分别点亮P2.0～P2.3引脚控制的4只LED，即S0、S1均闭合，LED0亮，其余灭；S1闭合、S0打开，LED1亮，其余灭；S0闭合、S1打开，LED2亮，其余灭；S0、S1均打开，LED3亮，其余灭。编程实现此功能。
>
> <a name="5-4">图5-4</a>
>
> <img src="http://222.65.137.121:9702/images/2020/10/07/image-20201008104511205.png" alt="image-20201008104511205" style="zoom:50%;" />
>
> ```c#
> #include<reg51.h>		//包含头文件reg51.h
> void main()		//主函数main()
> {
>   char state;
>   do
>   {
>     P1=0xff;		//P1口为输入
>     state=P1;		//读入P1口的状态，送入state
>     state=state&0x03;		//屏蔽P1口的高6位
>     switch(state)		//判P1口低2位开关状态
>     {
>       case 0: P2=0x01;break; //P1.1、P1.0=00，点亮P2.0脚LED
>       case 1: P2=0x02;break; //P1.1、P1.0=01，点亮P2.1脚LED
>       case 2: P2=0x04;break; //P1.1、P1.0=10，点亮P2.2脚LED
>       case 3: P2=0x08;break; //P1.1、P1.0=11，点亮P2.3脚LED
>     }
>   }while(1);
> }
> ```

# 单片机控制LED数码管的显示

## LED数码管显示原理

- LED数码管： “8”字型，7段（不包括小数点）或8段（包括小数点），每段对应一个发光二极管，共阳极和共阴极两种，见[图5-5](#5-5)。共阳极数码管的阳极连接在一起，接+5V；共阴极数码管阴极连在一起接地。
- 对于共阴极数码管，当某发光二极管阳极为高电平时，发光二极管点亮，相应段被显示。同样，共阳极数码管阳极连在一起，公共阳极接+5V，当某个发光二极管阴极接低电平时，该发光二极管被点亮，相应段被显示。
- <img src="http://222.65.137.121:9702/images/2020/10/07/image-20201008105145210.png" alt="image-20201008105145210" style="zoom: 33%;" /><a name="5-5"> </a>

- 为使LED数码管显示不同字符，要把某些段点亮，就要为数码管各段提供一字节的二进制码，即字型码（也称段码）。习惯上以“a”段对应字型码字节的最低位

- <img src="http://222.65.137.121:9702/images/2020/10/07/image-20201008105441169.png" alt="image-20201008105441169" style="zoom: 33%;" />

- 例如某存储单元中的数为“02H”，想在共阳极数码管上显示“2”，需要把“2”的字型码“A4H”加到数码管各段。将欲显示字符的字型码作成一个表（数组），根据显示字符从表中查找到相应字型码，然后把该字型码输出数码管各个段上，同时数码管的公共端接+5V，此时在数码管上显示字符“2”。

- > 例5-5：利用单片机控制一个8段LED数码管先循环显示单个偶数：0、2、4、6、8，再显示单个奇数：1、3、5、7、9，如此反复循环显示
  >
  > <img src="http://222.65.137.121:9702/images/2020/10/07/image-20201008105835291.png" alt="image-20201008105835291" style="zoom:50%;" />
  >
  > ```C#
  > #include <reg51.h>
  > #include <intrins.h>
  > #define uchar unsigned char
  > #define uint unsigned int
  > #define uint unsigned int
  > #define out P0
  > uchar code
  > seg[]={0xc0,0xa4,0x99,0x82,0x80,0xf9,0xb0,0x92,0xf8,0x90,0x01};
  > 	//共阳极段码表
  > void delayms(uint);
  > void main(void)
  > {
  >   uchar i;
  >   while(1)
  >   {
  >     out=seg[i];
  >     delayms(900);
  >     i++;
  >     if(seg[i]==0x01)i=0;	//如段码为0x01，表明一个循环显示已结束
  >   }
  >   void delams(uint j)	//延时函数
  >   {
  >     uchar i;
  >     for(;j>0;j--)
  >     {
  >       i=250;
  >       while(--i);
  >       i=249;
  >       while(--i);
  >     }
  >   }
  > }
  > ```
  >
  > *说明：语句“if(seg[i]==0x01)i=0; ” 含义：如果欲送出的数组元素为0x01（数字“9”段码0x90的下一个元素，即结束码），表明一个循环显示已结束，则i=0，则重新开始循环显示，从段码数组表的第一个元素seg[0]，即段码0xc0（数字0）重新开始显示*

## LED数码管的静态显示与动态显示

### 静态显示

- 无论多少位LED数码管，都同时处于显示状态
- 多位LED数码管工作于静态显示方式时，各位共阴极（或共阳极）连接在一起并接地（或接+5V）；每位数码管段码线（a～dp）分别与一个8位I/O口锁存器输出相连。如果送往各个LED数码管所显示字符的段码一经确定，则相应I/O口锁存器锁存的段码输出将维持不变，直到送入下一个显示字符段码。静态显示方式**显示无闪烁，亮度较高**，软件控制较易
- [图5-7](#5-7)为4位LED数码管静态显示电路，各数码管可独立显示，只要向控制各位I/O口锁存器送相应显示段码，该位就能保持相应的显示字符
- 这样在同一时间，每一位显示的字符可各不相同。静态显示方式**占用I/O口端口线较多**。图5-7电路，**要占用4个8位I/O口（或锁存器）**。如数码管数目增多，则需增加I/O口数目
- <img src="http://222.65.137.121:9702/images/2020/10/08/image-20201008111315906.png" alt="image-20201008111315906" style="zoom:33%;" /><a name="5-7"> </a>

> 例5-6：单片机控制2只数码管，静态显示2个数字“27”。 原理电路见[图5-8](#5-8)
>
> 分析：单片机用**P0口与P1口**，分别控制加到两个数码管DS0与DS1的**段码**，而共阳极数码管DS0与DS1的公共端（公共阳极端）直接接至+5V，因此数码管DS0与DS1始终处于导通状态。利用P0口与P1口带有的锁存功能，**只需向单片机P0口与P1口分别写入相应的显示字符“2”和“7”的段码即可**
>
> <img src="http://222.65.137.121:9702/images/2020/10/08/image-20201008111439991.png" alt="image-20201008111439991" style="zoom:50%;" /><a name="5-8">图5-8</a>
>
> ```c#
> include <reg51.h>		//包含8051单片机寄存器定义的头文件
> void main(void)
> {
>   P0=0xa4;		//将数字”2“的段码送P0口
>   P1=0xf8;		//将数字”7“的段码送P1口
>   while(1)		//无限循环
>   ;
> }
> ```

### 动态显示方式

- 显示位数较多时，静态显示所占的I/O口多，这时常采用动态显示。为节省I/O口，通常将所有显示器**段码线相应段并联**在一起，由一个8位I/O口控制，各显示位公共端分别由另一单独I/O口线控制
- <img src="http://222.65.137.121:9702/images/2020/10/08/image-20201008112014826.png" alt="image-20201008112014826" style="zoom:50%;" /><a name="5-9"> </a>

- 动态显示就是单片机向段码线输出欲显示字符的段码。**每一时刻，只有1位位选线有效，**即选中某一位显示，其他各位位选线都无效。每隔一定时间逐位轮流点亮各数码管（扫描方式），由于数码管余辉和人眼的“视觉暂留”作用，只要控制好每位数码管显示时间和间隔，则可造成“多位同时亮”的假象，达到同时显示效果。

- 各位数码管轮流点亮的时间间隔（扫描间隔）应根据实际情况定。发光二极管从导通到发光有一定的延时，如果点亮时间太短，发光太弱，人眼无法看清；时间太长，产生闪烁现象，且此时间越长，占用单片机时间也越多。另外，显示位数增多，也将占用单片机大量时间，因**此动态显示实质是以执行程序时间来换取I/O端口减少**

- > 例5-7：8只数码管，分别滚动显示单个数字1～8。程序运行后，单片机控制左边第1个数码管显示1，其他不显示，延时之后，控制左边第2个数码管显示1，其他不显示，直至第8个数码管显示8，其他不显示，反复循环上述过程。
  >
  > 分析：P0口输出段码，P2口输出扫描的位控码，通过由8个NPN晶体管的位驱动电路对8个数码管位控扫描。即使扫描速度加快，由于是虚拟仿真，数码管的余辉也不能像实际电路那样体现出来。如对本例实际硬件显示电路进行快速扫描，由于数码管余辉和人眼 “视觉暂留”作用，只要控制好每位数码管显示的时间和间隔，则可造成“多位同时亮” 假象，达到同时显示效果
  >
  > <img src="http://222.65.137.121:9702/images/2020/10/08/image-20201008114017557.png" alt="image-20201008114017557" style="zoom:50%;" /><a name="5-10"> </a>
  >
  > ```c#
  > #include<reg51.h>
  > #include<intrins.h>
  > #define uchar unsigned char
  > #defin uint unsigned int
  > uchar code
  > dis_code[]={0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0xc0};
  > 	//共阳数码管段码表
  > void delay(uint t)		//延时函数
  > {
  >   uchar i;
  >   while(t--) for(i=0;i<200;i++);
  > }
  > void main()
  > {
  >   uchar i,j=0x80;
  >   while(1)
  >   {
  >     for(i=0;i<8;i++)
  >     {
  >       j=_crol_(j,1);	//_crol_(j,1)为将对象j循环左移一位
  >       P0=dis_code[i];	//P0口输出段码
  >       P2=j;		//P2口输出位控码
  >       delay(180);		//延时，控制每位显示的时间
  >     }
  >   }
  > }
  > ```
  >

# 单片机控制LED点阵显示器显示

- LED点阵显示器分为**图文显示器**和**视频显示器**，有单色显示，还有彩色显示。下面仅介绍单片机如何来控制**单色LED点阵显示器**的显示。

## LED点阵显示器结构与显示原理

- 由若干个发光二极管按矩阵方式排列而成。阵列点数可分为**5×7、5×8、6×8、8×8点阵**；按发光颜色可分为**单色、双色、三色**；按极性排列可分为**共阴极**和**共阳极**

1. LED 点阵结构：以8×8LED点阵显示器为例，外形见[图5-11](#5-11)，内部结构见[图5-12](#5-12)，由64个发光二极管组成，且每个发光二极管是处于行线（R0~R7）和列线（C0~C7）之间交叉点上。

2. LED点阵显示原理：显示的字符由一个个点亮的LED所构成

   由[图5-12](#5-12)点亮点阵中一个发光二极管条件：对应行为高电平，对应列为低电平。如在很短时间内依次点亮很多个发光二极管，LED点阵就可显示一个稳定字符、数字或其他图形。控制LED点阵显示器显示，实质就是控制加到行线和列线上编码，控制点亮某些发光二极管（点），从而显示出由不同发光点组成的各种字符。

   <img src="http://222.65.137.121:9702/images/2020/10/08/image-20201008114843622.png" alt="image-20201008114843622" style="zoom:50%;" />

   

- > 例5-8：如[图5-14](#5-14)，利用单片机及 74LS154（4-16译码器）、74LS07、16×16 LED点阵显示屏来实现字符显示，编写程序，循环显示字符“电子技术”。
  >
  > 分析：图中16×16 LED点阵显示屏16行行线R0~R15电平，由P1口低4位经4-16译码器74HC154的16条译码输出线L0~L15经驱动后的输出来控制。16列列线C0~C15的电平由P0口和P2口控制。剩下问题是如何确定显示字符的点阵编码，以及控制好每一屏逐行显示的扫描速度（刷新频率）。 
  >
  > <img src="http://222.65.137.121:9702/images/2020/10/11/image-20201011185510259.png" alt="image-20201011185510259" style="zoom:50%;" /><a name="5-14"> </a>
  >
  > ```C#
  > #include<reg51.h>
  > #define uchar unsigned char
  > #define uint unsigned int
  > #define out0 P0
  > #define out2 P2
  > #define out1 P1
  > void delay(uint j)		//延时函数
  > {
  >   uchar i=205;
  >   for(;j>0;j--)
  >   {
  >     while(--i);
  >     i=100;
  >   }
  > }
  > uchar code string[]={
  >   //汉字“电”，16×16点阵列码
  >   //汉字“子”，16×16点阵列码
  >   //汉字“技”，16×16点阵列码
  >   //汉字“术”，16×16点阵列码
  > };
  > void main()
  > {
  >   uchar i,j,n;
  >   while(1)
  >   {
  >     for(j=0;j<4;j++)		//共显示4个汉字
  >     {
  >       for(n=0;n<40;n++)		//每个汉字整屏扫描40次
  >       {
  >         for(i=0;i<16;i++)		//逐行扫描16行
  >         {
  >           out1=i%16;		//输出行码
  >           out0=string[i*2+j*32];		//输出列码C0~C7,逐行扫描
  >           out2=string[i*2+1+j*32];		//输出列码C8~C15,逐行扫描
  >           delay(4);		//显示并延时一段时间
  >           out0=0xff;		//列线C0~C7为高电平，熄灭发光二极管
  >           out2=0xff;		//列线C8~C15为高电平，熄灭发光二极管
  >         }
  >       }
  >     }
  >   }
  > }
  > ```
  >
  > 扫描显示时，单片机通过P1口低4位经4-16译码器74HC154的16条译码输出线L0~L15经驱动后的输出来控制，**逐行为高电平**，来进行扫描。由P0口与P2口控制列码的输出，从而显示出某行应点亮的发光二极管。